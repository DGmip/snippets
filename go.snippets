snippet gopher
	/*
						 ,_---~~~~~----._
		_,,_,*^____      _____``*g*\"*,
	 / __/ /'     ^.  /      \ ^@q   f
	[  @f | @))    |  | @))   l  0 _/
	 \`/   \~____ / __ \_____/    \
		|           _l__l_           I
		}          [______]           I
		]            | | |            |
		]             ~ ~             |
		|                            |
		 |                           |
		  ${1}
	*/
# shorthand variable declaration
snippet v
	${1} := ${2}
# variable initialization
snippet vr
	var ${1:t} ${0:string}
# variable declaration
snippet var
	var ${1} ${2} = ${3}
# variables declaration
snippet vars
	var (
		${1} ${2} = ${3}
	)
# append
snippet ap
	append(${1:slice}, ${0:value})
# bool
snippet bl
	bool
# byte
snippet bt
	byte
# break
snippet br
	break
# channel
snippet ch
	chan ${0:int}
# case
snippet cs
	case ${1:value}:
		${0}
# const
snippet c
	const ${1:NAME} = ${0:0}
# constants with iota
snippet co
	const (
		${1:NAME1} = iota
		${0:NAME2}
	)
# continue
snippet cn
	continue
# defer
snippet df
	defer ${0:func}()
# defer recover
snippet dfr
	defer func() {
		if err := recover(); err != nil {
			${0}
		}
	}()
# gpl
snippet gpl
	/*
	 * This program is free software; you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation; either version 2 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program; if not, see <http://www.gnu.org/licenses/>.
	 *
	 * Copyright (C) ${1:Author}, `strftime("%Y")`
	 */

	${0}
# int
snippet i
	int
snippet appengine
# import normal package
snippet im
	import (
		"fmt"
		"${1:package}"
	)
# import toolkit package
snippet imt
	import (
		"fmt"
		"github.com/dgmip/toolkit/${1:package}"
	)
# interface
snippet in
	interface{}
# full interface snippet
snippet inf
	interface ${1:name} {
		${2:/* methods */}
	}
# if condition
snippet if
	if ${1:/* condition */} {
		${2}
	}
# else snippet
snippet el
	else {
		${1}
	}
# error snippet
snippet ir
	if err != nil {
		return err
	}
	${0}
# false
snippet f
	false
# fallthrough
snippet ft
	fallthrough
# float
snippet fl
	float32
# float32
snippet f3
	float32
# float64
snippet f6
	float64
# if else
snippet ie
	if ${1:/* condition */} {
		${2}
	} else {
		${3}
	}
	${0}
# for loop
snippet fo
	for ${2:i} := 0; $2 < ${1:count}; $2${3:++} {
	}
	${0}
# for range loop
snippet fr
	for ${1:k}, ${2:v} := range ${3} {
		${4}
	}
	${0}
# function simple
snippet fun
	func ${1:funcName}(${2}) ${3:returns} {
		${4}
	}
	${0}
# function on receiver
snippet fum
	func (${1:receiver} ${2:type}) ${3:funcName}(${4}) ${5:error} {
		${6}
	}
	${0}
# log printf
snippet lf
	log.Printf("%${1:s}", ${2:var})
# log printf
snippet lp
	log.Println("${1}")
snippet pl
	fmt.Println(${1})
# make
snippet mk
	make(${1:[]string}, ${0:0})
snippet msi
	${0} := make(map[string]int)
# map
snippet mp
	map[${1:string}]${0:int}
# main()
snippet main
	func main() {
		${1}
	}
	${0}
# new
snippet nw
	new(${0:type})
# package
snippet pa
	package ${1:main}
# panic
snippet pn
	panic("${0:msg}")
# print
snippet pf
	f := "${1:formatting}"
	fmt.Printf(f, ${2})
snippet pr
	fmt.Print(${1})
# range
snippet rn
	range ${0}
# return
snippet rt
	return ${0}
# result
snippet rs
	result
# select
snippet sl
	select {
	case ${1:v1} := <-${2:chan1}
		${3}
	case ${4:v2} := <-${5:chan2}
		${6}
	default:
		${0}
	}
# string
snippet sr
	string
# struct
snippet st
	struct ${1:name} {
		${2:/* data */}
	}
	${0}
# switch
snippet sw
	switch ${1:var} {
	case ${2:value1}:
		${3}
	case ${4:value2}:
		${5}
	default:
		${0}
	}
snippet sp
	fmt.Sprintf("%${1:s}", ${2:var})
# true
snippet t
	true
# goroutine named function
snippet g
	go ${1:funcName}(${0})
# goroutine anonymous function
snippet ga
	go func(${1} ${2:type}) {
		${3:/* code */}
	}(${0})
snippet test test function
	func Test${1:name}(t *testing.T) {
		${2}
	}
	${0}
snippet bench benchmark function
	func Benchmark${1:name}(b *testing.B) {
		for i := 0; i < b.N; i++ {
			${2}
		}
	}
	${0}
# start ben stuff
snippet my
	"github.com/dgmip/${1}"
snippet err
	if err != nil {
		${1:text}
	}
snippet go
	package ${1:main}

	import (
		"${2:fmt}"
	)
snippet cr
	// -- comment request --  ${1:text}
snippet cd
	// -- comment request --  describe the role of the file
snippet httprouter
	"github.com/julienschmidt/httprouter"
snippet range
	for ${1:_}, ${2:x} := range ${3:x}{${4:}
	}
snippet hf
	http.HandleFunc("/${1:route}/", $1${2:Handler})
snippet fp
	fmt.Fprintf(w, "${1:formatter}", ${2:variables})
snippet redirect
	http.Redirect(w, r, ${1:location}, http.StatusFound)
snippet fprint
	fmt.Fprint(w, ${1:var})
snippet template
	var ${1:var}Template = template.Must(template.New("${2:$1}").Parse(${3:file}))
snippet gtemplate
	template.Add("/${1:name}").Template("dist/pages/${2:$1}")
snippet bra
	"${1:text}": []string{"${2:text}","${3:text}","${4:text}"},
snippet '
	&#39;
# gaml start
# gaml start elements start
snippet ngdir
	g.NgDIRECTIVE("${1:name}")${2}
snippet nginit
	.NgInit("${1}")
snippet col
	g.MdCOL("${1} ${2}")${3}
snippet col#
	g.MdCOL().Id("${1}")${2}
snippet col.
	g.MdCOL().Class("${1}")${2}
snippet col.a
	g.MdCOL("${1:start} ${2:center}").Class("${3}")${4}
snippet row
	g.MdROW("${1:start} ${2:center}")${2}
snippet row#
	g.MdROW("${1:start} ${2:center}").Id("${3}")${4}
snippet row.
	g.MdROW("${1:start} ${2:center}").Class("${3}")${4}
snippet ngb
	g.B().Inner("${1}")
snippet ngd
	g.NgDIRECTIVE("${1}")${2}
snippet divi
	g.MdDIVIDER(${1:16}),${2}
snippet div
	g.DIV()${1}
snippet div.
	g.DIV().Class("${1}")${2}
snippet ngcla
	.NgClass("${1}")${2}
snippet but
	g.MdBUTTON()${1}
snippet but.
	g.MdBUTTON().Class("${1}")${2}
snippet mdib
	g.MdBUTTON().Class("md-icon-button")${1}
snippet arlab
	.AriaLabel("${1}")${2}
snippet span
	g.SPAN("${1}")${2}
snippet spani
	g.SPAN().Inner("${1}"),${2}
snippet spant
	g.SPAN().Interpolate("${1}")${2}
snippet span.
	g.SPAN("${2}").Class("${1}"),
snippet mdinp
	g.INPUT("${1:label}", "${2:model}")
snippet input
	g.INPUT()${1}
snippet mdsidenav
	g.SIDENAV("${1:md-component-id}")${2}
snippet nginc
	g.NgINCLUDE("${1:src}")
snippet mdtoolbar
	g.TOOLBAR()${1}
snippet mdcontent
	g.CONTENT().Add(${1}), // md-content end
snippet mdsel
	g.MDSELECT("${1:model}", "${2:placeholder}")${3}
snippet mdopt
	g.MDOPTION("${1:value}")${2}
snippet pre
	g.PRE("${1}")${2}
snippet gimg
	g.IMG()${1}
snippet gifr
	g.IFRAME()${1}
snippet ngp
	g.P()${1}
snippet ngp.
	g.P().Class("${1}")${2}
snippet mdprogc
	g.MdPROGRESSCIRCULAR("${1:indeterminate}", "${2:value}")
snippet ngh
	g.H(${1})
snippet ngh.
	g.H(${1}).Class("${2}")
snippet nga
	g.A().Attr("href", "${1:href}")${2}
snippet ngli
	g.LI()${1}
snippet ngll
	g.LI().Add(
		g.A().Attr("href", "${1:href}").Inner(${2})
	),
snippet nglia
	g.LI().Layout("row").Align("start center")${1}
snippet ngol
	g.OL()${1}
snippet ngul
	g.UL()${1}
snippet ngf
	g.FORM("${1:fuck-knows}")
snippet ico
	g.MdICON("${1:icon}"${2}),${3}
snippet icor
	g.ICONS("${1:icon}")RAttr("${2:size}", "${3}")${4}
snippet ico.
	g.ICONS("${1:icon}").Class("${2}")${3}
snippet mdtt
	g.MdTOOLTIP("${1:text}")${2}
snippet bre
	g.BR(),${1}
snippet mdtabs
	g.MdTABS()${0}
snippet tab
	g.MdTAB("${1:label}")${2}
snippet inlinestyles
	g.INLINESTYLES("${1}")${2}
# gaml elemnents end
# gaml attrs start
snippet layout
	.Layout("${1:row}")${2}
snippet layoutf
	.LayoutFill()${1}
snippet id
	.Id("${1}")${2}
snippet cla
	.Class("${1}")${2}
snippet nam
	.Name("${1}")${2}
snippet dev
	rc.Dev_Info("${1}"),
snippet ngc
	.NgController("${1}")${2}
snippet flexer
	g.DIV().Flex(-1),
snippet fle
	.Flex(${1:-1})${2}
snippet ini
	.Init("${1}")${2}
snippet ali
	.Align("${1:start} ${2:center}")${3}
snippet add
	.Add(${1}),
snippet addc
	.Add(${2}), // ${1} end
snippet sty
	.Style("${1}")${3}
snippet cli
	.NgClick("${1}")${2}
snippet inn
	.Inner("${1}")${2}
snippet int
	.Interpolate("${1}")${2}
snippet att
	.Attr("${1}")${2}
snippet rat
	.RAttr("${1}", "${2}")${3}
snippet attr
	.Attr("${1}", "${2}")${3}
snippet ngmod
	.NgModel("${1}")${2}
snippet ngent
	.NgEnter("${1}")${2}
snippet ngkey
	.NgKeyup("${1}")${2}
snippet ngblu
	.NgBlur("${1}")${2}
snippet ngfoc
	.NgFocus("${1}")${2}
snippet dirs
	.AttrDirs("${1}", "${2}"${3})${4}
snippet if
	.NgIf("${1}")${2}
snippet ngr
	.NgRepeat("${1}")${2}
snippet ngsh
	.NgShow("${1}")${2}
snippet ngimports
	"github.com/leadinglocally/microservices/ng/core"
	"github.com/leadinglocally/microservices/ng/components"
snippet ipsum
	Plaid flannel thundercats, magna photo booth banjo sartorial godard tilde. Ut PBR&B qui 8-bit, nostrud delectus four dollar toast cardigan nesciunt mixtape. Nostrud put a bird on it synth drinking vinegar. Mumblecore delectus chicharrones, bicycle rights church-key before they sold out portland cillum aesthetic placeat. Portland banjo aliquip lo-fi ethical. Biodiesel neutra brunch fixie meditation. Sed anim cray, yuccie viral velit enim tilde trust fund typewriter kogi.
snippet shortip
	Plaid flannel thundercats, magna photo booth banjo sartorial godard tilde.
snippet ngprevt
	components.NgPreviewTag("${1:display}", "${2:tagtype}", ${3:endorsements int}),
snippet ngsty
	.NgStyle("${1}")${2}
snippet ngloct
	components.NgLocationTag("${1:location display name}", "${2:flag code}")
snippet clo
	.NgCloak()${1}
snippet data
	d, ok := data.(map[string]interface{}); if !ok { panic(reflect.TypeOf(data).String() + " EXPECTED MAP STRING INTERFACE") }
# gaml end
# end ben stuff
# start alex code snippets
snippet getprop
	${1:propName}, ok := entity["${2:$1}"].(string); if !ok { panic(fn) }
snippet httperr
	app.client.HttpError(fn, res, "${0:error text}", 400); return
snippet httpred
	http.Redirect(res, r, "/"+rc.Language.Code+"/${1:url}", 308)
snippet gamlfunc
	func (rc *RequestContext) ${1:Elename}(data interface{}) *g.ELEMENT {
			return g.NgINCLUDE("/${2}")
	}
snippet logstr
	app.client.Debug(fn, ${1})
snippet logrand
	app.client.DebugJSON(fn, ${1})
snippet logerr
	app.client.Error(fn, ${1})
snippet logstrerr
	app.client.NewError(fn, ${1})
snippet gamlpage
	package pages

	import (
		g "github.com/golangdaddy/gaml"
		// "github.com/leadinglocally/microservices/ng/components"
	)

	func (rc *RequestContext) page(data interface{}) *g.ELEMENT {
		ele := g.MdROW("start center").Id("").NgController("AboutCtrl").SetData(data)
		return ele.Add(
			g.COL().Inner("ter"),
		)
	}
snippet lang
	" + rc.Language.Code + "
snippet country
	" + rc.Country.Code + "
snippet route
	case "${1:route-name}":

		title := "${2:$1}"

		app.RenderSSR(rc, res, rc.${3:function}, title, nil, false, false)
		return
snippet assert
	${1:test}, ok := ${2:i}.(${3:string}); if !ok { reflect.TypeOf(${4:$2}).String() }
# gaml repo start
snippet head

	// --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
	//  ${1:title} - http://www.w3schools.com/tags/ref_av_dom.asp
	// --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

snippet gele
	func (rc *RequestContext) ${1:Element_Name}(data interface{}) *g.ELEMENT {${2}
snippet bg
	.BackgroundImage("${1:url}", "${2:size}", "${3:pos}")
snippet del
	g.Delims("${1:key}")
snippet dell
	<!! .${1:thing} !!>
snippet ngcloak
	.NgCloak()
snippet enc
	<!! encodeJSON .${1} !!>
# gaml repo end
snippet random
	"math/rand"
	"time"
	rand.Seed(time.Now().UTC().UnixNano())
	// answers[rand.Intn(len(answers))]
# ben go snippets
snippet blank
	// remove me when done developing - I just stop the 'declared and not used error' from pissing you off
	_ = ${1:var}
snippet checker
	func check(err error) {
		if err != nil {
			panic(err)
		}
	}

snippet ch
	;check(err)
snippet readfile
	file, err := os.Open("file.go") // For read access.
	if err != nil {
		log.Fatal(err)
	}
# read user input
snippet reader
	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Enter text: ")
	text, _ := reader.ReadString('\n')
	fmt.Println(text)
snippet girlfriend
	"github.com/golangdaddy/gf"
snippet registerpage
	"web_${1:name(key)}":					func (req gf.RequestInterface) *gf.ResponseStatus {

		ok, app := Guest(req.Path(), req.Res(), req.R()); if !ok { return nil }
		status, rc := app.NewRequestContext(req, app.client); if status != nil { return status }

		title := "${2:$1}"

		return rc.RenderPage(req, "dist/templates/pages/proposal.page.html", title, nil, true, false)

	},
snippet registerssr
	"web_${1:name(key)}":					func (req gf.RequestInterface) *gf.ResponseStatus {

		ok, app := Guest(req.Path(), req.Res(), req.R()); if !ok { return nil }
		status, rc := app.NewRequestContext(req, app.client); if status != nil { return status }

		title := "${2:$1}"

		return app.RenderSSR(req, rc.web_$1, title, nil, true, false)

	},
snippet handler
	func ${1:handlerName}Handler(w http.ResponseWriter, r *http.Request){
	}
snippet handleFunc
	http.HandleFunc("/${1}", ${2:handler})
snippet setjson
	w.Header().Set("Content-Type", "application/json")
snippet te
	// tested: ${1:not} working
snippet key
	"${1}": ${2},${3}
snippet jo

	josh.Add("about-${1}").Run("web_josh_About_${2}", "GET")

snippet sr
	SendRequests(fn, method, url string, retries int, data interface{}) (bool, []byte) {

